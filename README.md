# Meeting_Client-Server-System
## how to use
・プログラムの起動時に、ユーザ名(英文字15文字以内)、待ち受けポート番号をコマンドラインで指定する。
　指定がなかった場合は、ユーザ名は「Anoymous」（匿名）、ポート番号は50001が使用される。

### <クライアント＞
・クライアントとしてサーバとの接続に成功すると、
　「Connected to the server. [サーバーのアドレス] [ポート番号]
　　You can disconnect by Entering "QUIT".」
　と表示される。

・その後キーボードで文字列を入力してエンターを押すと、
　発言メッセージがサーバとログインしている全ユーザに送信される。

・サーバや他のクライアントからのメッセージを受信すると、画面に表示される。

・キーボードでQUITと入力してエンターを押すと、サーバとの接続を閉じてプログラムを終了する。

### ＜サーバ＞
・クライアントとしてサーバとの接続試行に３回失敗すると、
　「Server is not found.
　　From now on you are the server.」
　と表示され、自身がサーバとなる。

・クライアントのログインまたはログアウトがあると、
　「User [ユーザ名] logged in(out).」
　というように、ユーザ名と共にユーザの動きが表示される。

・ログインしたユーザからメッセージを受信すると、
　自身の画面に表示すると共に他のユーザにメッセージを送信する。
　自身の発言メッセージはログインしている全ユーザに送信する。

・サーバのメインループはエラーが発生しない限り終了することはない。

　
## feature of system
・ユーザー名の指定がなかった場合は匿名者(Anonymous)として扱っている。

・サーバを探している間は「Looking for a server」と画面に表示し、
　「HELO」パケットを送信する度に「.（ピリオド）」がメッセージの末尾に３つまで追加されるようになっており、
　サーバの捜索時間を視覚的に表現している。

・サーバプログラムがダウンした場合はクライアントプログラムも
　"Server is down."のメッセージを表示して終了する。

・サーバプログラムのメインループではいずれかのポートの受信で処理がブロックしないよう
　UDPポート、接続待ち受け用のTCPポート、接続済みクライアントとの通信用ポートをselectによって監視している。
　また、select()の引数に必要な全ソケットディスクリプタの最大値は、毎回のループで全探索を行なって決めている。

・接続済みクライアントとの通信用ポートを監視するためのビットマスクは、
　接続要求を受けたAccept()の返り値を格納した変数tcpsock_acceptedを用いてセットしている。
　その後、このポートで「JOIN」パケットを受信し、ソケット番号を含むユーザの情報を線形リストに追加した後、
　tcpsock_acceptedの値を0にリセットすることで、最後にログインしたユーザの線形リストに格納されたポート番号の監視と、
　tcpsock_acceptedの値による同じポート番号の監視が重複することを防いでいる。
　また、これによって、クライアントがTCPでconnectした後、「JOIN」パケットを送ってこない、という不具合にも対応できるようにしている。

・「MESG」パケットの送信と「QUIT」パケットの処理のタイミングによって、既にcloseされたソケットに対してメッセージを送信してしまう
　場合に、シグナルSIGPIPEの発生によってサーバプログラムが終了してしまわないように、send()にMSG_NOSIGNALフラグを付け、
　SIGPIPE発生時にerrnoの値を確認することで対象のクライアントのログアウト処理を行う。

・クライアントが「QUIT」パケットを送信せずにコネクションを切断するなど、正常な終了動作が行われなかった場合は、
　自身の環境で実験した結果、サーバは「POST」パケットを繰り返し受信し続け、最後にFINパケット（recv()の返り値が0）を受け取る、
　という動作をすることがわかったため、サーバーが受信したバッファの中身の先頭が「POST POST 」となっていた場合、
　クライアントが異常終了したと判断し、「The connection has been lost.」とメッセージを表示して
　そのユーザのログアウト処理を行うものとした。


## プログラムの苦労した点
・クライアントプログラムのHEREパケットを受信したときにループから抜け出す処理において、
　接続試行のループは多重ループになっていたので、break文を２回使用する必要があり、
　実装に工夫が必要だった。

・線形リストが維持されるようにノードの消去を実装するのが大変だった。

・クライアントが「QUIT」パケットを送信しない異常終了した場合の対応を
　試行錯誤を何度も繰り返しながら実装した。

・どの機能を関数化するのか、しないのか、というようにプログラムの階層化における
　線引きが難しかった。
